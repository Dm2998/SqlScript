	Contents:																									  Page

		SELECT   Example Statements   (Transact SQL)

1.		Generic Format of SELECT:		. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	  3
2.		SELECT   * ;       SELECT Columns ;   WHERE clause:	. . . . . . . . . . . . . . . . . . . .	  3
3.		Limit the Number of Rows Returned  ( very useful !! )  TOP 5;  TOP 5 %:	. . . . . .	  3
4.		Aliasing Column Names:	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	  4
5.		Quotation Marks:		. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	  4
6.		Data Type Precedence:	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	  4
7.		Arithmetic Operators / Operator Precedence  ( Brackets ) :									  5
8.		Using String Operators:		. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	  5
9.		Unique Results:   DISTINCT:		. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	  5
10.	Comparison Operators for WHERE clause  /  Case Sensitivity:								  5

11.	Ranges:   BETWEEN  &  NOT BETWEEN :	. . . . . . . . . . . . . . . . . . . . . . . . . . . . .	  6
12.	Use of Lists:   IN & NOT IN   &  Subqueries:	. . . . . . . . . . . . . . . . . . . . . . . . . . . . .	  6
13.	Unknown Values:  IS NULL  &  IS NOT NULL:	. . . . . . . . . . . . . . . . . . . . . . . . . . .	  6
14.	Date Formats  NB:		. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .		  6
15.	Grouping Data & Aggregate Functions:	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	  7
16.	Ordering Results:  ORDER BY:	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	  7

17.	JOINS  ( > 1 table) :	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .		  8

18.	Union of 2 Result Sets !:	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	11
19.	SELECT INTO   &   #Temporary Tables:	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	11
20.	Stored Procedures :	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .	11
21.	Some differences between VMS Rdb & SQL Server 2012:	. . . . . . . . . . . . . . . . . . . .	12




 

1.		Generic Format of SELECT:
		The Generic syntax of the SELECT statement is as follows:
		SELECT			< select list >
			FROM			< table list>
			WHERE		< search condition>
			GROUP BY			< grouping column list>
			HAVING				< search condition >
			ORDER BY			< select list >

2.		SELECT   * ;       SELECT Columns ;   WHERE clause:
		To select all columns and all rows from a table:
		SELECT  *  FROM  local_office_code				(			 963 rows – time < 1 second	) 
		SELECT  *  FROM  customers 						( 		7,887,702 rows – time > 4½ mins	)
		To select a number of particular columns from a table:
		SELECT  local_office_code, local_office_name, county_name FROM  local_office_code
		To select a number of particular columns from a table for particular rows  <search condition>:
		SELECT  local_office_code, local_office_name FROM local_office_code 
		  WHERE county_name  = ‘Louth’					( 		   14 rows 	)
		SELECT  local_office_code, local_office_name FROM local_office_code 
		  WHERE county_name  LIKE  ‘%Louth%’		( 		   18 rows 	)
		Note:		We can use square brackets for column & table names but these are optional.
					These are also generated by the SELECT Wizard !!  
							Position the Right Mouse over the Table Name in the Object Browser (LHS) 
							Drag the Table Name to the Query Window (RHS) and release.
					The Full name of the table can also be used  (dbo = Database Owner)
					One may encounter full/abbreviated Table Name formats which may
							indicate   Database.TableOwner.TableName   as shown:
		SELECT  local_office_code, local_office_name  FROM  [dbBOMMain].[dbo].[local_office_code]
		SELECT  local_office_code, local_office_name  FROM  dbBOMMain.dbo.local_office_code
		SELECT  local_office_code, local_office_name  FROM  dbBOMMain..local_office_code

3.		Limit the Number of Rows Returned  ( very useful !! )  TOP 5;  TOP 5 %:
		To select all columns and all rows from a table but limit results to just 3 rows.
		Useful for getting a feel for actual data values in table.
		SELECT  TOP 3 *  FROM  Customer
		SELECT  TOP 3 PERCENT *  FROM  Customer		( 230,263 rows – time 2 mins )

		The equivalent statement in RDB on the VMS System would be
		SELECT  *  FROM  customer  LIMIT TO 3 rows;


4.		Aliasing Column Names  (very useful !! ):
		There are a number of ways we can give Different Column Headings for Results .
		SELECT  local_office_code, A  =  local_office_name 		FROM local_office_code 
		SELECT  local_office_code, local_office_name A			FROM local_office_code 
		SELECT  local_office_code, local_office_name ‘A’			FROM local_office_code 
		SELECT  local_office_code, local_office_name AS ‘A’	FROM local_office_code 
		SELECT  local_office_code, local_office_name AS “A”	FROM local_office_code 
		SELECT  local_office_code, local_office_name AS  A		FROM local_office_code     (prefer)
		SELECT  local_office_code, local_office_name AS ‘A  B’  FROM local_office_code 
		The equivalent statement in RDB would be
		SELECT  local_office_code, local_office_name AS “A  B”  FROM local_office_code 

5.		Quotation Marks:
		Rules:		You can use  Single or  Double Quotes  for Identifiers i.e. Column aliases.
						Its probably best to just stick to Single Quotes.
						Use	 Single Quotes  for	Literals  ( ‘C%’ )
						Use 2	 Single Quotes  to	include a quote in the middle of a literal:
		Option: 		There is an option to issue the command  SET QUOTED_IDENTIFIER OFF 
						but it is not advised to use this,  as identifiers can’t then be quoted and must then
						follow all TRANSACT SQL rules exactly.
		Examples:
		SELECT  local_office_name FROM local_office_code WHERE local_office_name LIKE ‘C%’
‘’
		SELECT	customer_id,  client_surname FROM customer 
 				WHERE  client_surname =  ‘O’’Leary’

		SELECT  ‘They’’re on our database’  +  client_surname   FROM   customer
		Notes:		LIKE ‘C%’  is used to return all records starting with C;  the % is a wild character.
						The use of   “C%”  would produce an error.

6.		Data Type Precedence:
		If  expressions mix data types then the data types of some fields may be converted to allow 
		the compution to complete.  An INT and a SMALLINT will force the SMALLINT to be
		converted to an INT just for the calculation.  One can see the precedence of data types 
		in the data type hierarchy with the following command:
		
		SELECT   name,  type   FROM   systypes   ORDER BY   type



 

7.		Arithmetic Operators / Operator Precedence  ( Brackets ) :
		The normal Arithmetic Operators can be used:	 +  -  *  /   and  %  (Modulus operator)
		SELECT  TOP 3		customer_id, 
									prb_reck_earnings_amt, 
									prb_reck_earnings_amt  *  2  FROM  Customer_Con_Year
		SELECT  15 / 4								
		SELECT  15 % 4							
		SELECT  3 + 6 * 9							
		SELECT  ( 3 + 6 )  * 9
		SELECT  ( ( 3 + 6 ) * 9 )
		Notes:		If a column used in an Arithmetic calculation has a NULL value for a particular
						row then the result will be NULL.
						The Precedence of Arithmetic operators is	*		/		%		+		-
						but to be sure of coding the requirement in the expression, it is best to use Brackets.

8.		Using String Operators:
		To Concatenate String expressions (literals)  and column values use the ‘+’ (plus) operator.
		SELECT  TOP 5 client_firstname + ' ' + client_surname AS 'Full Name' FROM  customer
		SELECT  TOP 10		   local_office_code
 								+ ', ' +  local_office_name 
								+ ', ' +  manager_surname  FROM local_office_code
		Notes:		2 Rows have NULL in the State column.  There are 2 options.
						We can use CONCAT_NULL_YIELDS_NULL  or  the ISNULL function.
		SET			CONCAT_NULL_YIELDS_NULL   OFF
		SELECT  TOP 10		   local_office_code
 								+ ', ' +  local_office_name 
								+ ', ' + ISNULL(manager_surname, '****') FROM local_office_code

9.		Unique Results:   DISTINCT:
		To eliminate Duplicate rows from a result set, then use DISTINCT 
		SELECT  officer_location_type_id 				    FROM  officer_location
		SELECT  DISTINCT  officer_location_type_id  FROM  officer_location
		Notes:		If multiple rows have a NULL value then only 1 row with NULL will be returned.

10.	Comparison Operators for WHERE clause  /  Case Sensitivity:
		To test rows for particular ranges of values we can use logical expressions
		using the Comparison operators:   =		>		<		>=			<=			<>
		SELECT  local_office_code, local_office_name FROM local_office_code 
		  WHERE county_name  = ‘Louth’					( 		   14 rows 	)
		SELECT  TOP 10 * FROM  Customer_Con_Year  WHERE (			( wies_1 = 52 					)
 																						AND	( cons_class_code_1 = 'd1'	))
		Regarding Case Sensitivity, note that SQL Server is by default  NOT  Case Sensitive
		However, particular Databases can be set up to be Case Sensitive if required.

11.	Ranges:   BETWEEN  &  NOT BETWEEN :
		One can use the BETWEEN operator to perform range comparisons instead of  >=  &  <=.
		It is a matter of preference.
		SELECT  local_office_code, local_office_name FROM local_office_code 
  				 WHERE  ( local_office_name  BETWEEN  'N' AND 'P'  )		-- 18 rows:   all N & O
 		SELECT  local_office_code, local_office_name FROM local_office_code 
 				 WHERE  ( local_office_name  BETWEEN  'N' AND 'PZ'  )		-- 31 rows:   all N, O & P
 		SELECT  local_office_code, local_office_name FROM local_office_code 
 				 WHERE  ( local_office_name  BETWEEN  'N' AND 'Q'  )		-- 31 rows:   all N, O & P

12.	Use of Lists:  ( IN & NOT IN ) =  Subqueries:
		One can use Lists with the IN  and  NOT IN operators to test Set Membeship.
		One type of list can be a number of literals enclosed in parenthesis.
		Another list can be evaluated from a subordinate SELECT statement.
		SELECT  *  FROM  scheme_type  WHERE  sch_code  IN  ( ‘SPC’, ‘SPT’, ‘RF’ )
		SELECT  customer_id  FROM  life_event  
 		   WHERE  life_event_type_id
 				   IN  (  SELECT  life_event_type_id  FROM life_event_type WHERE desc = ‘Birth’ )

13.	Unknown Values:  IS NULL  &  IS NOT NULL:
		As with most RDBs the comparison test to include or exclude a row with “NULL” value is done
		 using the  IS NULL  and  IS NOT NULL operators.
		SELECT  *  FROM  local_office_code  WHERE  manager_surname  IS  NULL 			  778
		SELECT  *  FROM  local_office_code  WHERE  manager_surname  IS NOT  NULL		   185
		SELECT  *  FROM  local_office_code  WHERE  manager_surname  =  NULL			     Error
		Notes:		Be careful not to code like the last example.  It will not return a syntax error 
						But rather, it will return 0 rows, giving an erroneous answer.

14.	Date Formats  NB:
		It is very important to be careful with the Date Format entered in expressions.  This is because
		of  Native Language Support Considerations (NLS).  The PC/Client or the actual Server may
		have different settings.  Therefore,  the constant “12/05/2000” could mean the “12th May 2000”
		(European format) or the “5th December 2000” (American Format).
		Guidelines:		Date Constants should always be in Quotes (Single)
							Best to Explicitly state the Month & Century		‘12 May 2000’
							The safest format is											‘20000512’
		SET  LANGUAGE  us_english			(change language to “us_english” )			- - note mm / dd
  		SELECT * FROM Medical_Assessment WHERE Assessment_Date = '12/05/2009'; 	- -1 row	
  		SELECT * FROM Medical_Assessment WHERE Assessment_Date = '05-Dec-2009'; - -1 row
  		SELECT * FROM Medical_Assessment WHERE Assessment_Date = '20091205'; 	 	- -1 row 
  		SELECT * FROM Medical_Assessment WHERE Assessment_Date = '2009-12-05'; 	- -1 row 
 

		SET  LANGUAGE  british				(change language to “british” )					- - note dd / mm
  		SELECT * FROM Medical_Assessment WHERE Assessment_Date = '12/05/2009';    - -21 rows
  		SELECT * FROM Medical_Assessment WHERE Assessment_Date = '12-May-2009';- -21 rows
  		SELECT * FROM Medical_Assessment WHERE Assessment_Date = '20090512';      - -21 rows
  		SELECT * FROM Medical_Assessment WHERE Assessment_Date = '2009-12-05';   - -21 rows!
  		SELECT * FROM Medical_Assessment WHERE Assessment_Date = '12/05/09';    - -YY eg (21)
		Notes:		Ensure one sets the Language to be “British” to ensure European Date format
						Some of the formats give counter intuitive results.
						Therefore, the safest format for specifying dates is  ‘dd-mmm-yyyy’
						Regarding the Server, notice that when we RightClick   Properties  Advanced
						The 2 year cut off  is 2049   Date range 1950 to 2049  Best to use full Century.
		Some useful commands relating to Dates:
		SELECT		 @@LANGUAGE
		EXECUTE		SP_HELPLANGUAGE
	 	SELECT		getdate( )
		SELECT		datename(month,getdate( ) ) 

15.	Grouping Data & Aggregate Functions:
		The Group by clause organizes data into Groups.  Each set of rows in a Group is replaced
		by a single Row by applying the value expressions in the SELECT clause.
		Aggregate Functions such as  COUNT  or  AVG  or  SUM  return summary values either for
		the whole table or for Groups of Data.
		Therefore Aggregate Functions are often used with the GROUP BY clause.
		The columns that appear in the SELECT clause of a statement with GROUP BY
		must be either a grouping column or contained within an Aggregate Function.
		SELECT			bank_type_id,  COUNT(*)
 			 FROM			bank
		   GROUP BY		bank_type_id;
		The HAVING clause sets conditions on which groups to include in the results.  
		The HAVING clause is to GROUPs as what the WHERE clause is to Rows.
		SELECT			bank_type_id,  COUNT(*)
 			 FROM			bank
		   GROUP BY		bank_type_id
		   HAVING			bank_type_id > 1
16.	Ordering Results:  ORDER BY:
		Results can be ordered either Ascending or Descending or a combination of these for ordering
		By a number of fields.  The Default is ASCENDING 	( ASC )
		SELECT  bank_id, bank_name  FROM  bank  ORDER BY  bank_name;
		SELECT  bank_id, bank_name  FROM  bank  ORDER BY  bank_name DESC;
		SELECT  bank_id, bank_name  FROM  bank  ORDER BY  bank_name DESC, bank_id ASC;
		Notes:	The 3rd example orders by a combination of  bank_name  Descending and within each
					bank_name   it is  Ascending  by bank_id.
 

17.	Joining > 1 table:  JOINS:
		In order to retrieve data from 2 or more Tables we can use the concept of “Joins”.
		We normally join tables based on the “Relationships” (PK/FK Links) but we are not restricted
		to this.  However joins on non PK/FK links may not have associated indexes and are less efficient.

	17.1	In order to Join 2 tables, the 1st thing done (by the DBMS) is to form the Cartestian Product 
 			of the 2 tables  i.e.  Every row in 1 Table is concatenated with every row in the other Table.
			Notes:	The field  marital_Status_acode  is qualified by TableName  Marital_Status 
 						as the field is in the 2 tables.
						Give a list of Customers and their Marital Status
						The following statement results in   122,806,880  rows   ( 7,675,430  *  16). 
			SELECT	customer_id,  client_firstname,  client_surname, 
							 Marital_Status.marital_status_acode,  marital_status_descr   
				FROM	Customer,  Marital_Status
			Due to the large volume of records, one may use the following to shorten the time taken
			to evaluate statements, but the same JOIN principles apply.
			SELECT	Count (*)	FROM	Customer,  Marital_Status


	17.2	The next step is to specify the  joining fields (normally PK/FK link).  This effectively 
			selects records from the overall set of joined records that  “match”  on the joining field.
			Or put another way, it eliminates rows that  do not “match”  the joining field.
			Notes:	Give a list of Customers and their Marital Status
						The following statement results in   6,789,751  rows  ( is <  7,675,430 )
 						because some customer records have a marital_acode value of NULL.
			SELECT	customer_id,  client_firstname,  client_surname, 
							 Marital_Status.marital_status_acode,  marital_status_descr   
				FROM	Customer,  Marital_Status
				WHERE	Customer.marital_acode  =   Marital_Status.marital_acode
			Due to the large volume of records, one may use the following to shorten the time taken
			to evaluate statements, but the same JOIN principles apply
			SELECT	Count (*)	FROM	Customer,  Marital_Status
				WHERE	Customer.marital_acode  =   Marital_Status.marital_acode


			One may also see test results from this large volume JOIN by using the TOP 10 clause.
 			The following is my preferred layout for JOINs.
			SELECT	TOP 10	C.customer_id,
										C.client_firstname,
										C.client_surname,
										M.marital_acode,
										M.marital_descr
						FROM		Customer			C,  
 										Marital_Status	M
					WHERE  		(		 	( C.marital_acode  =  M.marital_acode	)
										AND		( M.marital_acode = ‘P’ 						) )
 

			(The following are based on the PUBS sample database e.g. – but Structure is same)

	17.3	We can alternatively use the  JOIN  syntax  instead of the  WHERE  clause.
			Notes:	This is known as the INNER JOIN as only rows that Match on the joining field 
						are returned.  
						Give a list of Authors (ids) and the Title (ids) of the books they have written.
						The following statement results in 25 Rows.
			SELECT		TitleAuthor.au_id,  title_id   
				FROM		Authors   JOIN   TitleAuthor
								ON  ( Authors.au_id  =  TitleAuthor.au_id )
																																		
	17.4	It is possible to Join more than 2 Tables in the one statement.
			Notes:	(Old Rdb efficiency problems because Cartesian Product / SQL Server can handle )
						Give a list of Authors (ids) and the actual Book Titles of the books they have written.
						The following statement results in 25 Rows.
			SELECT		Authors.au_id,  title
				FROM		Authors   JOIN   TitleAuthor  ON  ( Authors.au_id  =  TitleAuthor.au_id )
								JOIN   Titles  ON  ( TitleAuthor.title_id  =  Titles.title_id )
																																		
	17.5	Outer Joins:	It is also possible to return rows from either the LEFT or RIGHT tables
			that do NOT have a matching value in the Joining field in addition to matching rows.
			Notes:	(Old RDBs efficiency problems because Cartesian Product, not SQL Server)
						Give a list of Authors (ids) and the Title (ids) of the books they have written.
							and a list of Authors (ids) and who have not written books (no Title (ids).
						The following statement results in 30 Rows.
						This comprises the 25 from the INNER JOIN and the 5 extra records for
						Authors that haven’t written Books (yet!).  These 5 rows will have a NULL
						Value for title_id.
			SELECT		Authors.au_id,  title_id
				FROM		Authors   LEFT JOIN   TitleAuthor  
											 ON  ( Authors.au_id  =  TitleAuthor.au_id )								
																																		
	Extra:  (A less B)		One may attempt to just return the 5 rows a number of ways.   
								The 1st returns 0 records as the columns from title_id with  NULL 
										values don’t actually exist, so cannot be selected.
								The 2nd returns 5 records with  NULL 
								The 3rd  uses a Subquery and will return the 5 rows.
								One could also use a Temporary Table – Store original results in Temp 
										then  select where title_id IS NULL   (See Section 19)
	1.		SELECT		Authors.au_id,  title_id
				FROM		Authors   LEFT JOIN   TitleAuthor  
											 ON  ( Authors.au_id  =  TitleAuthor.au_id )
				WHERE	title_id  =  NULL									--  = NULL			
								Correct format on next page

	2.		SELECT		Authors.au_id,  title_id
				FROM		Authors   LEFT JOIN   TitleAuthor  
											 ON  ( Authors.au_id  =  TitleAuthor.au_id )
				WHERE	title_id  IS  NULL									--  IS NULL		

	3.		SELECT		au_id
				FROM		Authors
				WHERE	au_id  NOT IN 										--  NOT IN			
										( SELECT  au_id  FROM  titleAuthor )
																																		

	17.6	RIGHT Outer Joins &  FULL Outer Joins:	 
			By the same logic as in the previous section, we can specify statements that will 			}
			also give results for rows in the Right Table that don’t match the joining condition,		}
 			in addition to matching rows.																					}
			We can specify statements to give results for rows in either/both the LEFT or RIGHT	}
			tables that don’t match the joining condition FULL,   in addition to matching rows.		}
			(These 2 egs.  23 & 30 rows )																				}

			SELECT		T.title,  T.pub_id,  P.pub_id,  P.pub_name											}
				FROM		titles  AS T   RIGHT OUTER JOIN   publishers AS P							}
											 ON  ( T.pub_id  =  P.pub_id )												}
																																		

			SELECT		A.au_fname + ‘  ’  + A.au_lname  AS  “Name”
				FROM		Authors  AS  A   FULL OUTER JOIN   TitleAuthor  AS  TA
											 ON  ( A.au_id  =  TA.au_id )
																																		

	17.7	Table Aliases: 	As table names can be quite long, 
 			it is more convenient to use Aliases for the Table names.    ( this eg. 25 Rows)
			SELECT		A.au_id,  TA.title_id   
				FROM		Authors			AS A   
 				  JOIN		TitleAuthor	AS  TA
								ON  ( A.au_id  =  TA.au_id )











 

18.	Union of 2 Result Sets !:
		It is possible to combine the results of 2 different Select statements using the UNION operator.
		It is important that
				a)		Each Select returns the same number of Columns
				b)		The corresponding columns are specified on the same Domains i.e. (Data Types)
		You probably won’t need this operator often!

		SELECT  ‘Author Table’,  au_id  AS ‘Id’,  au_lname + au_fname  FROM  authors
		UNION
		SELECT  ‘Titles Table’,  title_id,  title  FROM  titles

19.	SELECT INTO   &   #Temporary Tables:
		The SELECT  …  INTO statement allows record sets to be used to create new tables
		This can be useful for specifying complex situations that may require a Temporary Table.
		Temporary tables can be specified using the Hash  “#”  symbol.
		Further processing can then be done on the temporary table.
		SELECT  au_id,  au_lname + au_fname as “fullname” INTO  #gmccAuthors FROM authors
		SELECT  *   FROM  #gmccAuthors
		DROP  TABLE   #gmccAuthors

20.	Stored Procedures :						See Also Part D =  more comprehensive
		It is possible to set up procedures and store them in the Database environment (rather
		than load up a SQL Script file everytime one wants to do the same processing.
		This procedure can then be “compiled & executed”.
		These procedures can be set up using the Enterprise Manager or coded directly.
		Start  	  Programs    MS SQL Server    Enterprise Mgr
		And expand Left hand side to you See “Stored Procedures” for your Database. 
		Then right click and code your procedure.			
		CREATE PROCEDURE  gmcc_Proc1													}
		AS																									}
				SELECT	au_lname,  au_fname,  title,  pub_name							}	not a great eg
					FROM		authors  A,  titles  T,  publishers  P,  titleAuthor  TA	}	more like a View
					WHERE	(			(A.au_id  =  TA.au_id)									}	See Part D
										And	(T.title_id  =  TA.title_id)								}	
										And	(T.pub_id  =  P.pub_id) )								}		
		
		EXECUTE  gmcc_Proc1					(Run the procedure using EXECUTE)
		gmcc_Proc1									(Run the procedure by referring to Name,
 															 must be the 1st statement in Batch))
		DROP  PROCEDURE   gmcc_Proc1
		Further examples in the Supplementary Handout show how to 
				Pass Parameters.
				Use of  GO  to delimit Procedures.
				Procedure Templates

 
 
21.	Some differences between VMS Rdb & SQL Server 2012:
		The following is a short list of some differences between VMS Rdb and SQL Server 2008.
		Most vendors of RDMBSs do not fully implement the SQL Standard as defined over the
		years by ANSI, ISO & JTC.  
		1.		Rdb				Attach 					to a particular database.
				SQL Server		Connect					”
		2.		Rdb				Limit to 10 rows 		to restrict the number of rows returned.
				SQL Server		Top 10 *
		3.		Rdb				||							to concatenate values.
				SQL Server		+									”
		4.		Rdb				Select …. INTO :temp_table			to insert into a temporary table
				SQL Server		Select …. INTO #temp_table					”
		5.		Rdb				Data Types 			to define various items of Data
				SQL Server		Data Types								”
				Note: 	Full discussion is beyond scope of session, but in particular, pay attention
							to the  Date & Time types  (compare with Rdb  “Date VMS” )
The columns 8, 9, 10 shows what versions of SQL Server that supports the data type 
							 8 =  SQL Server 2000
							 9 =  SQL Server 2005
							10 = SQL Server 2008
